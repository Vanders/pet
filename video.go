package main

import (
	"context"
	"image/color"
	"os"

	"github.com/veandco/go-sdl2/sdl"
)

const (
	windowHeight = 480
	windowWidth  = 360
	scr_w        = 40
	scr_h        = 25
	borderTop    = 30
	borderLeft   = 40
	VID_MEM      = 0x8000
)

type VideoROM [2048]Byte

func (r *VideoROM) Load(filename string) error {
	d, err := os.ReadFile(filename)
	if err != nil {
		return err
	}
	for n := range d {
		r[n] = Byte(d[n])
	}

	return nil
}

type Video struct {
	Read func(address Word) Byte // Read a single byte from the bus
	VRom VideoROM

	lastChar rune
	window   *sdl.Window
}

func (v *Video) Reset() error {
	v.VRom = VideoROM{}
	err := v.VRom.Load("roms/char-901447-10.bin")
	if err != nil {
		return err
	}

	// Initialize SDL & create a window
	err = sdl.Init(sdl.INIT_VIDEO)
	if err != nil {
		return err
	}

	v.window, err = sdl.CreateWindow("pet",
		sdl.WINDOWPOS_UNDEFINED,
		sdl.WINDOWPOS_UNDEFINED,
		windowHeight,
		windowWidth,
		sdl.WINDOW_SHOWN)
	if err != nil {
		return err
	}

	v.lastChar = rune(0)
	sdl.StartTextInput()

	return nil
}

func (v *Video) Redraw() error {
	surface, err := v.window.GetSurface()
	if err != nil {
		return err
	}

	// Clear the surface
	surface.FillRect(nil, 0x0)

	// Draw 40 x 25 characters
	var scr_y, scr_x int
	green := color.RGBA{G: uint8(255)}

	surface.Lock()
	var line [scr_w]Byte
	for y := int32(borderTop); scr_y < scr_h; y += 10 {
		y_addr := Word(VID_MEM + (scr_y * scr_w))
		// read 40 characters for the row
		for n := range line {
			line[n] = v.Read(y_addr + Word(n))
		}

		// For each row, draw 8 scanlines of 25 characters
		for l := int32(0); l < 8; l++ {
			scr_x = 0
			for x := int32(borderLeft); scr_x < scr_w; x += 10 {
				char := line[scr_x]
				romAddr := Word(char&0x7f)<<3 | Word(l&0x07)
				/*
					if char > 127 {
						romAddr |= 0x400
					}
				*/
				bits := v.VRom[romAddr]
				for p := int32(0); p < 8; p++ {
					if (bits<<p)&0x80 != 0 {
						surface.Set(int(x+p+1), int(y+l+1), green)
					}
				}
				scr_x++
			}
		}
		scr_y++
	}
	surface.Unlock()
	v.window.UpdateSurface()

	return nil
}

// EventLoop handles any events generated by the GUI
func (v *Video) EventLoop(ctx context.Context, events chan<- Event) {
	lastTicks := sdl.GetTicks()
	currentTicks := lastTicks

	for {
		select {
		case <-ctx.Done():
			return
		default:
			break
		}

		sdlEvent := sdl.PollEvent()
		switch event := sdlEvent.(type) {
		case *sdl.TextInputEvent:
			char := rune(event.Text[0])

			// If this key isn't the same as before, send a KEY_UP event for the previous key
			if v.lastChar != char {
				events <- EventKeypress{
					Key: Keypress{
						Char:  v.lastChar,
						State: KEY_UP,
					},
				}
			}

			// Remember what was typed for subsequent keypress events
			v.lastChar = char

			// Send a KEY_DOWN event for this printable key
			events <- EventKeypress{
				Key: Keypress{
					Char:  v.lastChar,
					State: KEY_DOWN,
				},
			}
		case *sdl.KeyboardEvent:
			k := Keypress{
				Keycode: int(event.Keysym.Sym),
			}

			// Only send KEY_DOWN events for non-printable keys are interesting
			if event.State == sdl.PRESSED {
				k.State = KEY_DOWN

				switch event.Keysym.Sym {
				case sdl.K_RETURN,
					sdl.K_ESCAPE,
					sdl.K_BACKSPACE:

					// Send new key press event
					events <- EventKeypress{
						Key: k,
					}
				default:
					// Ignore everything else; TextInputEvent will send KEY_DOWN events for those
					break
				}
			} else if event.State == sdl.RELEASED {
				k.State = KEY_UP

				// Send the last printable character that was typed with this KEY_UP and reset the key
				k.Char = v.lastChar
				v.lastChar = rune(0)

				// Send new key press event
				events <- EventKeypress{
					Key: k,
				}
			}
		case *sdl.QuitEvent:
			events <- EventQuit{}
		}

		// Wait 50ms and then redraw the screen
		currentTicks = sdl.GetTicks()
		if currentTicks > lastTicks+50 {
			err := v.Redraw()
			if err != nil {
				break
			}
			lastTicks = currentTicks
		}

		sdl.Delay(10)
	}
}

func (v *Video) Stop() {
	v.window.Destroy()

	sdl.Quit()
}
