package main

import (
	"context"
	"image/color"

	"github.com/veandco/go-sdl2/sdl"
)

const (
	windowHeight = 480
	windowWidth  = 360
)

type GUI struct {
	Video *Video

	lastChar rune
	window   *sdl.Window
}

func (g *GUI) Init() error {
	// Initialize SDL & create a window
	err := sdl.Init(sdl.INIT_VIDEO)
	if err != nil {
		return err
	}

	g.window, err = sdl.CreateWindow("pet",
		sdl.WINDOWPOS_UNDEFINED,
		sdl.WINDOWPOS_UNDEFINED,
		windowHeight,
		windowWidth,
		sdl.WINDOW_SHOWN)
	if err != nil {
		return err
	}

	g.lastChar = rune(0)
	sdl.StartTextInput()

	return nil
}

func (g *GUI) redraw() error {
	surface, err := g.window.GetSurface()
	if err != nil {
		return err
	}

	// Clear the surface & lock it
	surface.FillRect(nil, 0x0)
	surface.Lock()

	// Perform video refresh
	green := color.RGBA{G: uint8(255)}

	g.Video.Redraw(func(x, y int) {
		surface.Set(x, y, green)
	})

	// Unlock the surface & update the window
	surface.Unlock()
	g.window.UpdateSurface()

	return nil
}

// EventLoop handles any events generated by the GUI
func (g *GUI) EventLoop(ctx context.Context, events chan<- Event) {
	lastTicks := sdl.GetTicks()
	currentTicks := lastTicks

	keymap := make(map[sdl.Keycode]int)
	keymap[sdl.K_DOWN] = 0x11
	keymap[sdl.K_LEFT] = 0x1d
	keymap[sdl.K_UP] = 0x11
	keymap[sdl.K_RIGHT] = 0x1d
	keymap[sdl.K_LSHIFT] = 0x00
	keymap[sdl.K_RSHIFT] = 0x00
	keymap[sdl.K_HOME] = 0x13
	keymap[sdl.K_LCTRL] = 0x12 // Reverse

	for {
		select {
		case <-ctx.Done():
			return
		default:
			break
		}

		sdlEvent := sdl.PollEvent()
		switch event := sdlEvent.(type) {
		case *sdl.TextInputEvent:
			char := rune(event.Text[0])

			// If this key isn't the same as before, send a KEY_UP event for the previous key
			if g.lastChar != char {
				events <- EventKeypress{
					Key: Keypress{
						Char:  g.lastChar,
						State: KEY_UP,
					},
				}
			}

			// Remember what was typed for subsequent keypress events
			g.lastChar = char

			// Send a KEY_DOWN event for this printable key
			events <- EventKeypress{
				Key: Keypress{
					Char:  g.lastChar,
					State: KEY_DOWN,
				},
			}
		case *sdl.KeyboardEvent:
			k := Keypress{
				Keycode: int(event.Keysym.Sym),
			}

			// Remap certain special keys
			sym := event.Keysym.Sym
			switch sym {
			case sdl.K_DOWN,
				sdl.K_RIGHT,
				sdl.K_HOME,
				sdl.K_LCTRL:
				k.Keycode = keymap[sym]
			case sdl.K_UP,
				sdl.K_LEFT,
				sdl.K_LSHIFT,
				sdl.K_RSHIFT:
				k.Keycode = keymap[sym]
				k.Modifiers.Shift = true
			}

			// Only send KEY_DOWN events for non-printable keys that are interesting
			if event.State == sdl.PRESSED {
				k.State = KEY_DOWN

				switch sym {
				case sdl.K_RETURN,
					sdl.K_ESCAPE,
					sdl.K_BACKSPACE,
					sdl.K_LSHIFT,
					sdl.K_RSHIFT,
					sdl.K_DOWN,
					sdl.K_RIGHT,
					sdl.K_UP,
					sdl.K_LEFT:

					// Send new key press event
					events <- EventKeypress{
						Key: k,
					}
				default:
					// Ignore everything else; TextInputEvent will send KEY_DOWN events for those
					break
				}
			} else if event.State == sdl.RELEASED {
				k.State = KEY_UP

				// Send the last printable character that was typed with this KEY_UP and reset the key
				k.Char = g.lastChar
				g.lastChar = rune(0)

				// Send new key press event
				events <- EventKeypress{
					Key: k,
				}
			}
		case *sdl.QuitEvent:
			events <- EventQuit{}
		}

		// Wait 50ms and then redraw the screen
		currentTicks = sdl.GetTicks()
		if currentTicks > lastTicks+50 {
			err := g.redraw()
			if err != nil {
				break
			}

			lastTicks = currentTicks
		}

		sdl.Delay(10)
	}
}

func (g *GUI) Stop() {
	g.window.Destroy()

	sdl.Quit()
}
